Coolc.lexer.longString=\#%d ERROR String constant too long.\n
Coolc.lexer.nullInString=\#%d ERROR String contains null character.\n
Coolc.lexer.unterminatedString=\#%d ERROR Unterminated string constant, EOL found.\n
Coolc.lexer.escapedNullString=\#%d ERROR String contains escaped null character.\n
Coolc.lexer.EOFInString=\#%d ERROR EOF in string constant.\n
Coolc.lexer.EOFInComment=\#%d ERROR EOF in comment.\n
Coolc.lexer.unmatchedCloseComment=\#%d ERROR Unmatched *).\n
Coolc.lexer.generalError=\#%d ERROR "%s".\n
Coolc.semant.noMain=Class Main is not defined.\n
Coolc.semant.redefBasic=Redefinition of basic class: [%s]\n
Coolc.semant.inheritBasic=Class [%s] cannot inherit class [%s].\n
Coolc.semant.inheritSelfType=Class [%s] cannot inherit class [SELF_TYPE].\n
Coolc.semant.inheritSelf=Class [%s] impossible inheritance from self\n
Coolc.semant.redefined=Class [%s] redefined\n
Coolc.semant.cannotInherit=Cannot inherit from [%s]\n
Coolc.semant.cycle=Inheritance cycle detected, impossible to continue: [%s]\n
Coolc.semant.undefined=Class A inherits from an undefined class D\n
Coolc.semant.removeScope=existScope: can't remove scope from an empty symbol table.\n
Coolc.semant.repeatId=addId: can't add a symbol without a scope.\n
Coolc.semant.noScope=lookup: no scope in symbol table.\n
Coolc.semant.selfAttr='self' cannot be the name of an attribute.\n
Coolc.semant.typeNotFound=Type not declared: [%s:%s]\n
Coolc.semant.attrRedefinition=Redefinition of attribute not allowed: [%s]\n
Coolc.semant.attrInherited=Attribute [%s] is an attribute of an inherited class.\n
Coolc.semant.selfMethod='self' cannot be the name of an method.\n
Coolc.semant.methodRedefinition=Redefinition of method not allowed: [%s]\n
Coolc.semant.badRedefinition=In redefined method [%s], parameter type [%s] is different from original type [%s].\n
Coolc.semant.diffNFormals=In redefined method [%s], different number of formals.\n
Coolc.semant.formalRedefinition=Redefinition of formal not allowed: [%s]\n
Coolc.semant.selfFormal='self' cannot be the name of a formal parameter.\n
Coolc.semant.selfTypeFormal=Formal parameter [%s] cannot have type SELF_TYPE.\n
Coolc.semant.selfInLet='self' cannot be bound in a 'let' expression.\n
Coolc.semant.duplicateBranch=Duplicate branch [%s] in case statement.\n
Coolc.semant.undeclIdentifier=Undeclared identifier [%s].\n
Coolc.semant.badInferred=Inferred return type [%s] of method [%s] does not conform to declared return type [%s].\n
Coolc.semant.assignSelf=Impossible to assign 'self'.\n
Coolc.semant.badAssignment=Type [%s] of assigned expression does not conform to declared type [%s] of identifier [%s].\n
Coolc.semant.formalsFailedLong=In call of method [%s], type [%s] does not conform to declared type [%s].\n
Coolc.semant.formalsFailed=Formal type checking failed.\n
Coolc.semant.boolParam=%s parameter must be Bool.\n
Coolc.semant.notIntParams=%s parameters must be Int.\n
Coolc.semant.basicCompare=Illegal comparison with a basic type.\n
Coolc.semant.staticFailType=Static dispatch expr:[%s], expecting [%s].\n
Coolc.semant.dispatchUndefined=Dispatch to undefined method [%s].\n
Coolc.semant.badPredicate=Predicate in IF not boolean.\n
Coolc.semant.badLoop=Loop condition does not have type Bool.\n
Coolc.semant.badLetInit=Let initialization does not correspond to declared type.\n